{
  "hash": "faaee8883877c9cd79969b364d2e9b03",
  "result": {
    "markdown": "# Loading your data\n\nThe first step in any data analysis is to open up your favorite \nsoftware and load the data up. You are probably familiar with user interfaces,\nwhere you click some buttons, you upload your excel file and *voil√°*, data\nis ready to analyse. \n\nIn this chapter I will teach you how to format your qPCR data so you\ncan load it easily to R. I will also show you how to load the data itself.\n\n:::{.callout-warning}\nIf you are using RStudio, you can also click some buttons and load your \ndata, without writing any code. I strongly recommend you to **not** do \nthis. In the next sections I will show how you should be doing.\n:::\n\n## Formats, formats and more formats...\n\nIf you are here, you are probably used to excel and the format xlsx. \nR can open these files, however, it is easier to run\nyour analysis if you have your data in the *csv* format. For qPCR \nspecially, each qPCR machine, the excel sheet will be different and not \nin a standard format. Usually it is a table with several\ncells containing information regarding your run and other parameters.\n\nGiven your fresh table from the qPCR machine, we will extract some columns.\nIn qPCR experiments, usually there are three technical replicates for \nyour samples. This is reflected in how the data is saved. \n\nAn [example table](../data/qPCR.csv) is shown in the data folder.\n\n## How to load your data\n\nIf you saved your table as a csv file, then we have several\noptions to load the file. You can use the function `read.csv` or \n`read.table` from base R to open the tables. The way to use\nthese functions is shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqpcr <- read.csv(\"../data/qPCR.csv\")\nqpcr <- read.table(\"../data/qPCR.csv\", sep = \",\", header = TRUE)\n```\n:::\n\n\nNote that for `read.table` we need to specify the separator, in this case\nit is a comma (\",\") and we also specify `HEADER = TRUE`. This means the \nfirst row of your table is the header of your data frame. In general\nif you have a csv file, it is easier to run `read.csv`.\n\n## Checking the data\n\nWhen loading the data, it is very important to check if it was\nimported successfully or any problem happened. A package that we will\nbe using throughout this book is `dplyr`. Within `dplyr` we have some\nfunctions that help us deal data frames in a very intuitive way. \nThe first function we will use here to check the data is `glimpse`. \nWe load the package here, but it is best practice to load all the packages\nyou will be using at the beginning of your analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first we start by loading the library\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# we now use the function glimpse on our dataframe\nglimpse(qpcr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 72\nColumns: 4\n$ sample.ID <int> 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, ~\n$ group     <chr> \"WT C\", \"WT C\", \"WT C\", \"WT C\", \"WT C\", \"WT C\", \"WT C\", \"WT ~\n$ gene      <chr> \"AKT\", \"AKT\", \"AKT\", \"AKT\", \"AKT\", \"AKT\", \"AKT\", \"AKT\", \"AKT~\n$ ct        <dbl> 16.49, 16.44, 16.65, 16.50, 16.74, 16.68, 16.96, 16.92, 17.0~\n```\n:::\n:::\n\n\nThe function `glimpse` displays a summary of each column of your dataframe \nand their data types. We see that `sample_id` is an integer, `group`\nand `gene` are characters and finally the `ct` values are doubles, meaning\nthey are numeric. So far the data looks good. \n\nAnother way to use the function `glimpse` and other functions\nfrom the `dplyr` package is using the pipe `%>%`. The way to interpret\nthe pipe is the following. Given a dataframe, we pipe the dataframe\nto the next function. The syntax is shown in the code block below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqpcr %>% glimpse\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 72\nColumns: 4\n$ sample.ID <int> 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, ~\n$ group     <chr> \"WT C\", \"WT C\", \"WT C\", \"WT C\", \"WT C\", \"WT C\", \"WT C\", \"WT ~\n$ gene      <chr> \"AKT\", \"AKT\", \"AKT\", \"AKT\", \"AKT\", \"AKT\", \"AKT\", \"AKT\", \"AKT~\n$ ct        <dbl> 16.49, 16.44, 16.65, 16.50, 16.74, 16.68, 16.96, 16.92, 17.0~\n```\n:::\n:::\n\n\nThe output is the same as before, the difference is that we can use other\nfunctions and chain them together. For example, if we want to see\nonly the first 5 rows of the table and then select the row with \nmaximum ct value, we can use the function `head` followed by `slice_max`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqpcr %>% \n    head %>%\n    slice_max(order_by = ct) # specify the column by passing the name without quotes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  sample.ID group gene    ct\n1        21  WT C  AKT 16.74\n```\n:::\n:::\n\n\nThere is a flow of code when chaining functions like this. By also writing \ncode like this, it is easier to modify or add new steps to the chain.\n\n## Checkpoint\n\nWe now use `readRDS` to save our current matrix to load it up in the \nnext chapter. The checkpoints are not necessary. As this is a simple analysis,\nyou can run everything in a single script and loaded in your memory.\nThe good thing about checkpoints is that you can save heavy calculations so\nyou do not need to perform them again. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(qpcr, \"../checkpoints/loading/qpcr.rds\")\n```\n:::\n\n\n:::{.callout-tip}\n`readRDS` is a function that lets you save R objects into your computer.\nIt is extremely handy when you want to save expensive calculations or \ncontinue your analysis later. Note you are only saving one object. \n:::\n\n:::{.callout-tip}\nIf you are using quarto markdown or Rmarkdown, there is a chunk option\nthat you can use to not rerun that chunk, namely the `cache` option.\n:::\n\nFor each checkpoint, we save them in a specific folder for each\nchapter inside `checkpoints`, in the root folder. This ensures we know\nwhere the data was generated by pointing to the name of the chapter. ",
    "supporting": [
      "loading_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}